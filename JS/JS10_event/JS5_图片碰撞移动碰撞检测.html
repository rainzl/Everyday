<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title></title>
<style>
body {
	text-align: center;
}
input {
	cursor: pointer;
}
#box {
	position: relative;
	margin: 20px auto;
	text-align: center;
	padding: 10px 10px 0;
	width: 950px;
	border: 1px solid #00BFFF;
}
img {
	height: 123px;
	width: 300px;
	border: 5px dashed transparent;
	cursor: pointer;
	z-index: 1;
}
.red {
	border-color: #808080;
}
</style>
</head>
	
<body>
	<input value="随机排序" type="button" />
	<div id="box">
		<img src="img5/img1.gif" />
		<img src="img5/img2.gif" />
		<img src="img5/img3.gif" />
		<img src="img5/img4.gif" />
		<img src="img5/img5.gif" />
		<img src="img5/img6.gif" />
		<img src="img5/img7.gif" />
		<img src="img5/img8.gif" />
		<img src="img5/img9.gif" />
		<img src="img5/img10.gif" />
		<img src="img5/img11.gif" />
		<img src="img5/img12.gif" />
	</div>
<script src="JS/publicMain.js"></script>
<script>
(function(){
	var oBox = document.getElementById('box');
	var aImgs = Array.from(oBox.getElementsByTagName('img'));
	var btn = document.getElementsByTagName('input')[0];
	var arrPst = setPstArr();//存储每个元素的left和top
	
	setStyle(arrPst);
	
	//循环给每个元素添加碰撞检测和更换位置函数
	aImgs.forEach(function(item,i,arr){
		var arrTemp = [];
		arr.forEach(function(item){
			arrTemp.push(item);
		})
		var obj = arrTemp.shift();
		drag (obj,arrTemp);
		arr.push(arr.shift());
	})
	
	//点击随机切换
	btn.onclick = function () {
		//对存储每个元素left和top的数组进行排序
		arrPst.sort(function(){
			return Math.random() - 0.5;
		})
		//给每个元素重新设置left和top值
		setStyle(arrPst);
	}
	
	//碰撞检测函数。
	function drag (obj1,objArr) {
		var index;//存储锁定到的元素的下标
		var minNum = 1000;
		obj1.addEventListener('mousedown',fnDown);
		function fnDown(ev) {
			obj1.style.zIndex = 20;//被移动的元素层级提高
			var ev = ev || event;
			var disX = ev.pageX - this.offsetLeft,
				disY = ev.pageY - this.offsetTop;
			
			document.addEventListener('mousemove',fnMove);
			
			function fnMove(ev) {
				var ev = ev || event;
				var t = ev.pageY - disY,
					l = ev.pageX - disX;
					
				var arr = [];//存储与每个元素间的-距离-(fnPeng(obj1,obj2)这个函数的返回值)
				
				for ( var i=0; i<objArr.length; i++ ) {
					
					arr.push(fnPeng(obj1,objArr[i]));
				}
				minNum = Math.min.apply(null,arr);//计算数组中的最大值
				
				if ( minNum == 1000 ) {
					objArr.forEach(function(item){//清除样式
						item.className = '';
					});
				} else {
					index = arr.indexOf(minNum);//最大值在数组中的下标
					objArr.forEach(function(item){//清除样式
						item.className = '';
					});
					objArr[index].className = 'red';//设置当前锁定元素的样式
				}
				
				obj1.style.top = t + 'px';
				obj1.style.left = l + 'px';
					
			}
			document.addEventListener('mouseup',fnUp);
			function fnUp() {
				if (minNum == 1000) {
					mTween(obj1,{'top':obj1.t,'left':obj1.l},100,'linear');
				} else {
					obj1.style.zIndex = 1;//还原元素层级
					objArr[index].className = '';//样式清空
					change(obj1,objArr[index]);//执行元素位置互换的函数
				}
				
				document.removeEventListener('mousemove',fnMove);
				document.removeEventListener('mouseup',fnUp);
			}
			ev.preventDefault();
		}
	}
	//碰撞函数，已经碰撞到的返回计算后距离，没有碰撞到的返回0；
	function fnPeng(obj1,obj2) {
		var	l1 = obj1.offsetLeft,
			t1 = obj1.offsetTop,
			r1 = l1 + obj1.offsetWidth,
			b1 = t1 + obj1.offsetHeight;
		
		var l2 = obj2.offsetLeft,
			t2 = obj2.offsetTop,
			r2 = l2 + obj2.offsetWidth,
			b2 = t2 + obj2.offsetHeight;
		if ( r1<l2 || b1 < t2 || l1 > r2 || t1 > b2 ) {
			return 1000;
		} else {
			var num = Math.sqrt(Math.pow((l1 - l2),2)+Math.pow((t1-t2),2));
			return num;
		}
		
	}
	//元素位置互换的函数
	function change(obj1,obj2) {
		var jsonTemp = {};
		jsonTemp.l = obj1.l;
		jsonTemp.t = obj1.t;
		obj1.l = obj2.l;
		obj1.t = obj2.t;
		obj2.l = jsonTemp.l;
		obj2.t = jsonTemp.t;
		//console.log(obj2.l,obj2.t )
		obj1.style.top = obj1.t + 'px';
		obj1.style.left = obj1.l + 'px';
		mTween(obj1,{'top':obj1.t,'left':obj1.l},100,'linear');
		obj2.style.zIndex = 10;
		mTween(obj2,{'top':obj2.t,'left':obj2.l},400,'linear',function(){
			obj2.style.zIndex = 1;
		});
	}
	//初始化，设置每个元素的top和left，并存入数组
	function setPstArr(){
		var arr = [];
		oBox.style.height = oBox.clientHeight + 'px';
		for ( var i=0; i<aImgs.length; i++ ) {
			arr.push({'left':aImgs[i].offsetLeft,'top':aImgs[i].offsetTop});
		}
		return arr;
	}
	//根据数组，中的top和left。设置元素的位置
	function setStyle(arr) {
		for ( var i=0; i<aImgs.length; i++ ) {
			aImgs[i].l = arr[i].left;
			aImgs[i].t = arr[i].top;
			aImgs[i].style.position = 'absolute';
			mTween(aImgs[i],{'left':aImgs[i].l,'top':aImgs[i].t},400,'linear');
		}
	}
	
})()
</script>
</body>
</html>
